# coding: utf-8




import pprint
import re  # noqa: F401

import six


class PostGenerateBillingDocumentType(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'auto_post': 'bool',
        'auto_renew': 'bool',
        'charge_type_to_exclude': 'list[str]',
        'effective_date': 'date',
        'subscription_ids': 'list[str]',
        'target_date': 'date'
    }

    attribute_map = {
        'auto_post': 'autoPost',
        'auto_renew': 'autoRenew',
        'charge_type_to_exclude': 'chargeTypeToExclude',
        'effective_date': 'effectiveDate',
        'subscription_ids': 'subscriptionIds',
        'target_date': 'targetDate'
    }

    def __init__(self, auto_post=False, auto_renew=False, charge_type_to_exclude=None, effective_date=None, subscription_ids=None, target_date=None):  # noqa: E501
        """PostGenerateBillingDocumentType - a model defined in Swagger"""  # noqa: E501

        self._auto_post = None
        self._auto_renew = None
        self._charge_type_to_exclude = None
        self._effective_date = None
        self._subscription_ids = None
        self._target_date = None
        self.discriminator = None

        if auto_post is not None:
            self.auto_post = auto_post
        if auto_renew is not None:
            self.auto_renew = auto_renew
        if charge_type_to_exclude is not None:
            self.charge_type_to_exclude = charge_type_to_exclude
        if effective_date is not None:
            self.effective_date = effective_date
        if subscription_ids is not None:
            self.subscription_ids = subscription_ids
        if target_date is not None:
            self.target_date = target_date

    @property
    def auto_post(self):
        """Gets the auto_post of this PostGenerateBillingDocumentType.  # noqa: E501

        Whether to automatically post the billing documents after the draft billing documents are generated.   If an error occurs during posting billing documents, the draft billing documents are not generated too.   # noqa: E501

        :return: The auto_post of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: bool
        """
        return self._auto_post

    @auto_post.setter
    def auto_post(self, auto_post):
        """Sets the auto_post of this PostGenerateBillingDocumentType.

        Whether to automatically post the billing documents after the draft billing documents are generated.   If an error occurs during posting billing documents, the draft billing documents are not generated too.   # noqa: E501

        :param auto_post: The auto_post of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: bool
        """

        self._auto_post = auto_post

    @property
    def auto_renew(self):
        """Gets the auto_renew of this PostGenerateBillingDocumentType.  # noqa: E501

        Whether to automatically renew the subscriptions with **Auto Renew** set to **Yes**.    # noqa: E501

        :return: The auto_renew of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: bool
        """
        return self._auto_renew

    @auto_renew.setter
    def auto_renew(self, auto_renew):
        """Sets the auto_renew of this PostGenerateBillingDocumentType.

        Whether to automatically renew the subscriptions with **Auto Renew** set to **Yes**.    # noqa: E501

        :param auto_renew: The auto_renew of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: bool
        """

        self._auto_renew = auto_renew

    @property
    def charge_type_to_exclude(self):
        """Gets the charge_type_to_exclude of this PostGenerateBillingDocumentType.  # noqa: E501

        The types of the charges to be excluded from the generation of billing documents. The field values are case insensitive. Supported values include `onetime`, `recurring`, and `usage`.    # noqa: E501

        :return: The charge_type_to_exclude of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: list[str]
        """
        return self._charge_type_to_exclude

    @charge_type_to_exclude.setter
    def charge_type_to_exclude(self, charge_type_to_exclude):
        """Sets the charge_type_to_exclude of this PostGenerateBillingDocumentType.

        The types of the charges to be excluded from the generation of billing documents. The field values are case insensitive. Supported values include `onetime`, `recurring`, and `usage`.    # noqa: E501

        :param charge_type_to_exclude: The charge_type_to_exclude of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: list[str]
        """

        self._charge_type_to_exclude = charge_type_to_exclude

    @property
    def effective_date(self):
        """Gets the effective_date of this PostGenerateBillingDocumentType.  # noqa: E501

        The date on which to generate the billing documents, in `yyyy-mm-dd` format.   # noqa: E501

        :return: The effective_date of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: date
        """
        return self._effective_date

    @effective_date.setter
    def effective_date(self, effective_date):
        """Sets the effective_date of this PostGenerateBillingDocumentType.

        The date on which to generate the billing documents, in `yyyy-mm-dd` format.   # noqa: E501

        :param effective_date: The effective_date of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: date
        """

        self._effective_date = effective_date

    @property
    def subscription_ids(self):
        """Gets the subscription_ids of this PostGenerateBillingDocumentType.  # noqa: E501

        The IDs of the subscriptions that you want to create the billing documents for.    # noqa: E501

        :return: The subscription_ids of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: list[str]
        """
        return self._subscription_ids

    @subscription_ids.setter
    def subscription_ids(self, subscription_ids):
        """Sets the subscription_ids of this PostGenerateBillingDocumentType.

        The IDs of the subscriptions that you want to create the billing documents for.    # noqa: E501

        :param subscription_ids: The subscription_ids of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: list[str]
        """

        self._subscription_ids = subscription_ids

    @property
    def target_date(self):
        """Gets the target_date of this PostGenerateBillingDocumentType.  # noqa: E501

        The date used to determine which charges are to be billed, in `yyyy-mm-dd` format.   # noqa: E501

        :return: The target_date of this PostGenerateBillingDocumentType.  # noqa: E501
        :rtype: date
        """
        return self._target_date

    @target_date.setter
    def target_date(self, target_date):
        """Sets the target_date of this PostGenerateBillingDocumentType.

        The date used to determine which charges are to be billed, in `yyyy-mm-dd` format.   # noqa: E501

        :param target_date: The target_date of this PostGenerateBillingDocumentType.  # noqa: E501
        :type: date
        """

        self._target_date = target_date

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(PostGenerateBillingDocumentType, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, PostGenerateBillingDocumentType):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
